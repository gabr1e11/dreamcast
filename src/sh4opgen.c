/**
 * List of opcodes of the SH7750h.
 *
 * @see sh4opcode.def file for the definition of the input array for the LUT
 * table generation.
 *
 * The opcode definition is read and then 2 lookup tables are generated, one
 * for the dissassembler and the other one for the interpreter. This is 
 * Then the function implementation by default is:
 *
 *      void __1110nnnniiiiiiii(uin16_t op) {
 *          // mov #i,Rn
 *          fprintf(stderr, "[NOT IMPLEMENTED!!] mov #i,Rn --> __1110nnnniiiiiiii\n");
 *      }
 *
 * A sample implementation of the function could be:
 *
 *      void __1110nnnniiiiiiii(uin16_t op) {
 *          // mov #i,Rn
 *          register uint8_t Rn = (op>>8)&0xF;
 *          register uint8_t imm = op&0xFF;
 *          fprintf(stderr, " mov #%d,R%d\n", imm, Rn);
 *      }
 */
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <xlocale.h>

/* List of opcodes and mnemonics */
struct {
    char opcode[32];
    char mnemonic[32];
} opcodeDefs[] = {
    #include "sh4opcode.def"
};

/* Metadata needed to process the opcode definitions */
struct {
    char format[32];
    struct {
        char symbol;
        uint8_t firstBit;
        uint8_t numBits;
    } seenVars[3];
    uint8_t seenVarsOrder[3];
    uint8_t numSeenVars;
} opcodeDefsMeta[sizeof opcodeDefs/sizeof *opcodeDefs] = { 0 };

/* Internal LUT used to build up the final LUT */
uint16_t opcodeLUT[65536] = {0};

void WriteHeader(FILE *file, const char *name, const char *comment, bool disclaimer)
{
    fprintf(file, "/*********************************************\n");
    fprintf(file, " * %s\n", name);
    fprintf(file, " *\n");
    fprintf(file, " * %s\n", comment);
    fprintf(file, " *\n");
    fprintf(file, " * @author Roberto Cano <roberto dot cano at google mail>\n");
    fprintf(file, " *\n");
    if (disclaimer) {
        fprintf(file, " * THIS FILE IS AUTOMATICALLY GENERATED.\n");
        fprintf(file, " * DO NOT MODIFY!!!!\n");
        fprintf(file, " *\n");
    }
    fprintf(file, " *********************************************/\n");
}

int main(int argc, char **argv)
{
    uint32_t i, j, k, l, pos;
    uint8_t positions[12];
    uint8_t numPositions = 0;
    uint16_t base, opcode;
    char printVars[3];
    uint8_t numPrintVars;
    size_t mnemonicLen;
    char cDisFileName[256], cEmuFileName[256],
         cLUTFileName[256], hFileName[256];
    char hCPPLabel[256];
    FILE *cDisFile, *cEmuFile, *cLUTFile, *hFile;
    char *basename = argv[1];

    if (argc < 2) {
        fprintf(stderr, "Usage:\n\tsh4opgen <base_name>\n\n");
        fprintf(stderr, "\t<base_name> the base name for the generated files. 4 files\n");
        fprintf(stderr, "\tare generated:\n");
        fprintf(stderr, "\t\t<base_name>dis.c\n");
        fprintf(stderr, "\t\t<base_name>emu.c\n");
        fprintf(stderr, "\t\t<base_name>LUT.c\n");
        fprintf(stderr, "\t\t<base_name>.h\n");
        fprintf(stderr, "\n");
        exit(1);
    }

    snprintf(cDisFileName, sizeof cDisFileName, "%sdis.c", basename);
    snprintf(cEmuFileName, sizeof cEmuFileName, "%semu.c", basename);
    snprintf(cLUTFileName, sizeof cLUTFileName, "%sLUT.c", basename);
    snprintf(hFileName, sizeof hFileName, "%s.h", basename);
    snprintf(hCPPLabel, sizeof hCPPLabel, "__%s_H__", basename);
    i=0;
    while (hCPPLabel[i]) {
        hCPPLabel[i] = toupper(hCPPLabel[i]);
        i++;
    }

    cDisFile = fopen(cDisFileName, "w");
    cEmuFile = fopen(cEmuFileName, "w");
    cLUTFile = fopen(cLUTFileName, "w");
    hFile = fopen(hFileName, "w");

    if (cDisFile == NULL || cEmuFile == NULL ||
        cLUTFile == NULL || hFile == NULL) {
        fclose(cDisFile);
        fclose(cEmuFile);
        fclose(cLUTFile);
        fclose(hFile);
        fprintf(stderr, "ERROR could not open %s, %s, %s or %s\n",
                cDisFileName, cEmuFileName, cLUTFileName, hFileName);
        return 1;
    }

    /* Parse the input definition */
    for (i=0; i<sizeof opcodeDefs/sizeof *opcodeDefs; ++i) {
        for (j=0, base=0, numPositions=0; j<16; j++) {
            base <<= 1;
            if (opcodeDefs[i].opcode[j] == '1') {
                base |= 1;
            } else if (opcodeDefs[i].opcode[j] != '0') {
                /* Save the position of the variable bit of the mnemonic */
                positions[numPositions++] = 15-j;

                /* Process the symbols for precooked variables */
                for (l=0; l<opcodeDefsMeta[i].numSeenVars; ++l) {
                    if (opcodeDefsMeta[i].seenVars[l].symbol == opcodeDefs[i].opcode[j]) {
                        opcodeDefsMeta[i].seenVars[l].numBits++;
                        break;
                    }
                }
                if (l == opcodeDefsMeta[i].numSeenVars) {
                    /* We've seen a new symbol, save it */
                    opcodeDefsMeta[i].seenVars[opcodeDefsMeta[i].numSeenVars].symbol = opcodeDefs[i].opcode[j];
                    opcodeDefsMeta[i].seenVars[opcodeDefsMeta[i].numSeenVars].firstBit = 15-j;
                    opcodeDefsMeta[i].seenVars[opcodeDefsMeta[i].numSeenVars].numBits++;
                    opcodeDefsMeta[i].numSeenVars++;
                }
            }
        }
        /* Parse the mnemonic to find out the printing order
         * of the precooked variables */
        strcpy(opcodeDefsMeta[i].format, opcodeDefs[i].mnemonic);
        mnemonicLen = strlen(opcodeDefs[i].mnemonic);
        for (j=0, pos=0; j<mnemonicLen; ++j) {
            if (opcodeDefs[i].mnemonic[j] == '%' && j<mnemonicLen-1) {
                j++;

                /* Find the symbol in the precooked vars array */
                for (k=0; k<opcodeDefsMeta[i].numSeenVars; ++k) {
                    if (opcodeDefsMeta[i].seenVars[k].symbol == opcodeDefs[i].mnemonic[j]) {
                        opcodeDefsMeta[i].seenVarsOrder[pos++] = k;
                        break;
                    }
                }
                if (k == opcodeDefsMeta[i].numSeenVars) {
                    fprintf(stderr, "[CRITICAL!!] Please check mnemonic %d (%s, %s), syntax seems to be wrong\n",
                                     i, opcodeDefs[i].opcode, opcodeDefs[i].mnemonic);
                    exit(1);
                }

                /* Now fix the symbol so we can use it as a printf format string */
                opcodeDefs[i].mnemonic[j] = 'c';
                opcodeDefsMeta[i].format[j] = 'd';
            }
        }

        /* Generate all possible combinations */
        for (j=0; j<(1<<numPositions); j++) {
            opcode = base;
            for (k=0; k<numPositions; k++) {
                opcode |= ((j>>(numPositions-k-1))&0x1)<<positions[k];
            }
            opcodeLUT[opcode] = i;
        }
    }

    WriteHeader(cDisFile, cDisFileName, "Contains the implementation of the processing functions for the disassembler", true);
    WriteHeader(cEmuFile, cEmuFileName, "Contains the implementation of the processing functions for the emulator", false);
    WriteHeader(cLUTFile, cLUTFileName, "Contains the lookup table for the processing functions", true);
    WriteHeader(hFile, hFileName, "Header file with all the LUT definitions", true);

    /* Header file */
    fprintf(hFile, "#ifndef %s\n", hCPPLabel);
    fprintf(hFile, "#define %s\n", hCPPLabel);
    fprintf(hFile, "\n");
    fprintf(hFile, "#include <stdint.h>\n");
    fprintf(hFile, "\n");
    fprintf(hFile, "/* SH4 opcode processor type */\n");
    fprintf(hFile, "typedef void (*SH4OPProcesor_t)(uint16_t);\n");
    fprintf(hFile, "\n");
    fprintf(hFile, "/* Forward declaration of all opcode interpreter processors */\n");
    for (i=0; i<sizeof opcodeDefs/sizeof *opcodeDefs; ++i) {
        fprintf(hFile, "void __%s(uint16_t op); /**< %s */\n", opcodeDefs[i].opcode, opcodeDefs[i].mnemonic);
    }
    fprintf(hFile, "\n");

    fprintf(hFile, "/* Opcodes interpreter lookup table declaration */\n");
    fprintf(hFile, "extern SH4OPProcesor_t SH7750InterpLUT[];\n");
    fprintf(hFile, "\n");
    fprintf(hFile, "/* Forward declaration of all opcode disasembler processors */\n");
    fprintf(hFile, "#ifdef SH7750_ENABLE_DISASSEMBLER\n");
    for (i=0; i<sizeof opcodeDefs/sizeof *opcodeDefs; ++i) {
        fprintf(hFile, "void __%s_dis(uint16_t op); /**< %s */\n", opcodeDefs[i].opcode, opcodeDefs[i].mnemonic);
    }
    fprintf(hFile, "\n");

    fprintf(hFile, "/* Opcodes disassembler lookup table declaration */\n");
    fprintf(hFile, "extern SH4OPProcesor_t SH7750DisasmLUT[];\n");
    fprintf(hFile, "#endif // SH7750_ENABLE_DISASSEMBLER\n");
    fprintf(hFile, "\n");
    fprintf(hFile, "#endif // %s\n", hCPPLabel);

    /* File containing the LUT */
    fprintf(cLUTFile, "#include \"%s\"\n", hFileName);
    fprintf(cLUTFile, "\n");
    fprintf(cLUTFile, "/* Interpreter Lookup table definition */\n");
    fprintf(cLUTFile, "SH4OPProcesor_t SH7750InterpLUT[] = {\n");
    for (i=0; i<sizeof opcodeLUT/sizeof *opcodeLUT; ++i) {
        uint16_t defEntry = opcodeLUT[i];
        fprintf(cLUTFile, "__%s, /**< %s */\n", opcodeDefs[defEntry].opcode, opcodeDefs[defEntry].mnemonic);
    }
    fprintf(cLUTFile, "};\n");

    fprintf(cLUTFile, "/* Lookup table definition */\n");
    fprintf(cLUTFile, "#ifdef SH7750_ENABLE_DISASSEMBLER\n");
    fprintf(cLUTFile, "SH4OPProcesor_t SH7750DisasmLUT[] = {\n");
    for (i=0; i<sizeof opcodeLUT/sizeof *opcodeLUT; ++i) {
        uint16_t defEntry = opcodeLUT[i];
        fprintf(cLUTFile, "__%s_dis, /**< %s */\n", opcodeDefs[defEntry].opcode, opcodeDefs[defEntry].mnemonic);
    }
    fprintf(cLUTFile, "};\n");
    fprintf(cLUTFile, "#endif // SH7750_ENABLE_DISASSEMBLER\n");

    /* File containing the disassembling functions */
    fprintf(cDisFile, "#include \"%s\"\n", hFileName);
    fprintf(cDisFile, "#include <stdio.h>\n");
    fprintf(cDisFile, "\n");
    fprintf(cDisFile, "#ifdef SH7750_ENABLE_DISASSEMBLER\n");
    for (i=0; i<sizeof opcodeDefs/sizeof *opcodeDefs; ++i) {
        fprintf(cDisFile, "void __%s_dis(uint16_t op)\n", opcodeDefs[i].opcode);
        fprintf(cDisFile, "{\n");
        fprintf(cDisFile, "    /* ");
        fprintf(cDisFile, opcodeDefs[i].mnemonic, opcodeDefsMeta[i].seenVars[opcodeDefsMeta[i].seenVarsOrder[0]],
                          opcodeDefsMeta[i].seenVars[opcodeDefsMeta[i].seenVarsOrder[1]],
                          opcodeDefsMeta[i].seenVars[opcodeDefsMeta[i].seenVarsOrder[2]]);
        fprintf(cDisFile, " */\n");

        /* Precooked variables holding the needed ops */
        for (j=0; j<opcodeDefsMeta[i].numSeenVars; ++j) {
            if (opcodeDefsMeta[i].seenVars[j].numBits > 8) {
                fprintf(cDisFile, "    uint16_t ");
            } else {
                fprintf(cDisFile, "    uint8_t ");
            }
            if (opcodeDefsMeta[i].seenVars[j].firstBit+1-opcodeDefsMeta[i].seenVars[j].numBits > 0) {
                fprintf(cDisFile, "%c = (op>>%d)&0x%x;\n", opcodeDefsMeta[i].seenVars[j].symbol,
                                                           opcodeDefsMeta[i].seenVars[j].firstBit+1-
                                                           opcodeDefsMeta[i].seenVars[j].numBits,
                                                           (1<<opcodeDefsMeta[i].seenVars[j].numBits)-1);
            } else {
                fprintf(cDisFile, "%c = op&0x%x;\n", opcodeDefsMeta[i].seenVars[j].symbol,
                                                     (1<<opcodeDefsMeta[i].seenVars[j].numBits)-1);
            }
        }
        fprintf(cDisFile, "    fprintf(stdout, \"%s\\n\"", opcodeDefsMeta[i].format);
        for (j=0; j<opcodeDefsMeta[i].numSeenVars; ++j) {
            fprintf(cDisFile, ", %c", opcodeDefsMeta[i].seenVars[opcodeDefsMeta[i].seenVarsOrder[j]].symbol);
        }
        fprintf(cDisFile, ");\n");
        fprintf(cDisFile, "}\n");
        fprintf(cDisFile, "\n");
    }
    fprintf(cDisFile, "#endif // SH7750_ENABLE_DISASSEMBLER\n");

    /* File containing the emulator functions */
    fprintf(cEmuFile, "#include \"%s\"\n", hFileName);
    fprintf(cEmuFile, "#include <stdio.h>\n");
    fprintf(cEmuFile, "#include <stdlib.h>\n");
    fprintf(cEmuFile, "\n");
    for (i=0; i<sizeof opcodeDefs/sizeof *opcodeDefs; ++i) {
        fprintf(cEmuFile, "void __%s(uint16_t op)\n", opcodeDefs[i].opcode);
        fprintf(cEmuFile, "{\n");
        fprintf(cEmuFile, "    /* ");
                fprintf(cEmuFile, opcodeDefs[i].mnemonic, opcodeDefsMeta[i].seenVars[opcodeDefsMeta[i].seenVarsOrder[0]],
                                                          opcodeDefsMeta[i].seenVars[opcodeDefsMeta[i].seenVarsOrder[1]],
                                                          opcodeDefsMeta[i].seenVars[opcodeDefsMeta[i].seenVarsOrder[2]]);
        fprintf(cEmuFile, " */\n");

        /* Precooked variables holding the needed ops */
        for (j=0; j<opcodeDefsMeta[i].numSeenVars; ++j) {
            if (opcodeDefsMeta[i].seenVars[j].numBits > 8) {
                fprintf(cEmuFile, "    uint16_t ");
            } else {
                fprintf(cEmuFile, "    uint8_t ");
            }
            if (opcodeDefsMeta[i].seenVars[j].firstBit+1-opcodeDefsMeta[i].seenVars[j].numBits > 0) {
                fprintf(cEmuFile, "%c = (op>>%d)&0x%x;\n", opcodeDefsMeta[i].seenVars[j].symbol,
                                                           opcodeDefsMeta[i].seenVars[j].firstBit+1-
                                                           opcodeDefsMeta[i].seenVars[j].numBits,
                                                           (1<<opcodeDefsMeta[i].seenVars[j].numBits)-1);
            } else {
                fprintf(cEmuFile, "%c = op&0x%x;\n", opcodeDefsMeta[i].seenVars[j].symbol,
                                                     (1<<opcodeDefsMeta[i].seenVars[j].numBits)-1);
            }
        }
        fprintf(cEmuFile, "    fprintf(stderr, \"[NOT IMPLEMENTED!] ");
        fprintf(cEmuFile, opcodeDefs[i].mnemonic, opcodeDefsMeta[i].seenVars[opcodeDefsMeta[i].seenVarsOrder[0]],
                                                  opcodeDefsMeta[i].seenVars[opcodeDefsMeta[i].seenVarsOrder[1]],
                                                  opcodeDefsMeta[i].seenVars[opcodeDefsMeta[i].seenVarsOrder[2]]);
        fprintf(cEmuFile, " --> __%s\\n\");\n", opcodeDefs[i].opcode);
        fprintf(cEmuFile, "    exit(1);\n");
        fprintf(cEmuFile, "}\n");
        fprintf(cEmuFile, "\n");
    }

    fclose(cDisFile);
    fclose(cEmuFile);
    fclose(cLUTFile);
    fclose(hFile);

    fprintf(stdout, "Done!\n");
    return 0;
}
